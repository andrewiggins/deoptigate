<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PrismJS</title>
    <link
      href="https://unpkg.com/prismjs@1.20.0/themes/prism.css"
      rel="stylesheet"
    />
    <link
      href="https://unpkg.com/prismjs@1.20.0/plugins/line-numbers/prism-line-numbers.css"
      rel="stylesheet"
    />
  </head>
  <body>
    <script
      type="text/javascript"
      src="https://unpkg.com/prismjs@1.20.0/prism.js"
    ></script>
    <script
      type="text/javascript"
      src="https://unpkg.com/prismjs@1.20.0/plugins/unescaped-markup/prism-unescaped-markup.js"
    ></script>
    <script
      type="text/javascript"
      src="https://unpkg.com/prismjs@1.20.0/plugins/line-numbers/prism-line-numbers.js"
    ></script>
    <!-- 
      Looking a theme.browser.js, consider putting markers at the end of the current token if inside of a token.
      This is challenging because not all tokens are highlighted by PrismJS so some are in in the middle of a 
      Text node. Would need to parse the text node to determine the current token and insert markup appropriately
     -->

    <script type="text/javascript">
      const DEBUG = true
      function validateLoc(lineCount, columnCount, fullText) {
        if (!DEBUG) return

        const lineLengths = fullText.split('\n').map((l) => l.length)
        const expectedColCount = lineLengths[lineCount - 1] + 1
        if (expectedColCount !== columnCount) {
          console.error(`${lineCount}:`, expectedColCount, columnCount)
        }
      }

      /**
       * @param {Node} element
       * @param {Node} root
       */
      function nextElement(element, root) {
        if (element == root) {
          return null
        } else if (element.firstChild) {
          return element.firstChild
        } else if (element.nextSibling) {
          return element.nextSibling
        } else {
          do {
            element = element.parentNode
          } while (element && element != root && !element.nextSibling)

          return element ? element.nextSibling : null
        }
      }

      function getIcon(type) {
        if (type == 'code') {
          return '▲'
        } else if (type == 'deopt') {
          return '▼'
        } else {
          return '☎'
        }
      }

      function locHasMarker(markers, curLine, curColumn) {
        const nextMarker = markers[0]
        return (
          markers.length > 0 &&
          curLine == nextMarker.line &&
          curColumn >= nextMarker.column
        )
      }

      function consumeMarkers(element, markers, curLine, curColumn) {
        let refChild = element
        while (locHasMarker(markers, curLine, curColumn)) {
          const marker = markers.shift()

          const lastMark = document.createElement('mark')
          lastMark.textContent = getIcon(marker.type)

          element.parentNode.insertBefore(lastMark, refChild.nextSibling)
          refChild = lastMark
        }

        return refChild
      }

      const typeOrder = ['code', 'deopt', 'ics']
      function sortMarkers(markers) {
        return markers.sort((loc1, loc2) => {
          if (loc1.line != loc2.line) {
            return loc1.line - loc2.line
          } else if (loc1.column != loc2.column) {
            return loc1.column - loc2.column
          } else if (loc1.type != loc2.type) {
            return typeOrder.indexOf(loc1.type) - typeOrder.indexOf(loc2.type)
          } else {
            return 0
          }
        })
      }

      const markers = sortMarkers([
        { line: 9, column: 27, type: 'code' },
        { line: 11, column: 20, type: 'code' },
        { line: 95, column: 22, type: 'code' },
        { line: 98, column: 33, type: 'deopt' },
        { line: 98, column: 33, type: 'ics' },
        { line: 98, column: 39, type: 'ics' },
        { line: 99, column: 18, type: 'deopt' },
        { line: 109, column: 17, type: 'deopt' },
        { line: 109, column: 17, type: 'ics' },
        { line: 111, column: 21, type: 'ics' },
        { line: 139, column: 26, type: 'code' },
        { line: 142, column: 34, type: 'deopt' },
      ])

      Prism.hooks.add('after-highlight', (env) => {
        let code = ''

        /** @type {Node} */
        const root = env.element
        /** @type {Node} */
        let element = root.firstChild
        let lineCount = 1,
          columnCount = 1
        while (element) {
          if (element.nodeType == 3 /* TEXT_NODE */) {
            const text = element.data
            code += text

            // Handle of text node contains multiple lines
            // TODO - Inserting markers in the middle of a text node doesn't work
            const lines = text.split('\n')
            for (let i = 0; i < lines.length; i++) {
              if (i > 0) {
                // Reached end of line
                validateLoc(lineCount, columnCount, env.code)

                lineCount += 1
                columnCount = 1
              }

              const line = lines[i]
              columnCount += line.length

              if (locHasMarker(markers, lineCount, columnCount)) {
                const lastMark = consumeMarkers(
                  element,
                  markers,
                  lineCount,
                  columnCount
                )

                element = nextElement(lastMark, root)
              }
            }
          }

          element = nextElement(element, root)
        }

        console.log(code == env.code, lineCount == 158, columnCount == 8)
      })
    </script>

    <pre
      class="language-markup line-numbers"
    ><code id="code"><!--<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Adders (inline)</title>
  </head>
  <body>
    <script type="module">
      class Object1 {
        constructor(x, y) {
          this.x = x
          this.y = y
        }
      }

      class Object2 {
        constructor(x, y) {
          this.y = y
          this.x = x
        }
      }

      class Object3 {
        constructor(x, y) {
          this.hello = 'world'
          this.x = x
          this.y = y
        }
      }

      class Object4 {
        constructor(x, y) {
          this.x = x
          this.hello = 'world'
          this.y = y
        }
      }

      class Object5 {
        constructor(x, y) {
          this.x = x
          this.y = y
          this.hello = 'world'
        }
      }

      class Object6 {
        constructor(x, y) {
          this.hola = 'mundo'
          this.x = x
          this.y = y
          this.hello = 'world'
        }
      }

      class Object7 {
        constructor(x, y) {
          this.x = x
          this.hola = 'mundo'
          this.y = y
          this.hello = 'world'
        }
      }

      class Object8 {
        constructor(x, y) {
          this.x = x
          this.y = y
          this.hola = 'mundo'
          this.hello = 'world'
        }
      }
      // We access this object in all the functions as otherwise
      // v8 will just inline them since they are so short
      const preventInlining = {
        flag: false,
      }

      function addSmis(a, b) {
        if (preventInlining.flag) return a - b
        return a + b
      }

      function addNumbers(a, b) {
        if (preventInlining.flag) return a - b
        return a + b
      }

      function addStrings(a, b) {
        if (preventInlining.flag) return a - b
        return a + b
      }

      function addAny(a, b) {
        if (preventInlining.flag) return a - b
        // passed one object?
        if (b == null) return a.x + a.y
        return a + b
      }

      const ITER = 1e3

      var results = []

      function processResult(r) {
        // will never happen
        if (r === -1) preventInlining.flag = true
        results.push(r)
        // prevent exhausting memory
        if (results.length > 1e5) results = []
      }

      for (let i = 0; i < ITER; i++) {
        for (let j = ITER; j > 0; j--) {
          processResult(addSmis(i, j))
          processResult(addNumbers(i, j))
          processResult(addNumbers(i * 0.2, j * 0.2))
          processResult(addStrings(`${i}`, `${j}`))
          // Just passing Smis for now
          processResult(addAny(i, j))
        }
      }

      for (let i = 0; i < ITER; i++) {
        for (let j = ITER; j > 0; j--) {
          // Adding Doubles
          processResult(addAny(i * 0.2, j * 0.2))
        }
      }

      for (let i = 0; i < ITER; i++) {
        for (let j = ITER; j > 0; j--) {
          // Adding Strings
          processResult(addAny(`${i}`, `${j}`))
        }
      }

      function addObjects(SomeObject) {
        for (let i = 0; i < ITER; i++) {
          for (let j = ITER; j > 0; j--) {
            processResult(addAny(new SomeObject(i, j)))
          }
        }
      }
      addObjects(Object1)
      addObjects(Object2)
      addObjects(Object3)
      addObjects(Object4)
      addObjects(Object5)
      addObjects(Object6)
      addObjects(Object7)
      addObjects(Object8)

      console.log(results.length)
    </script>
  </body>
</html>--></code></pre>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PrismJS</title>
    <link
      href="https://unpkg.com/prismjs@1.20.0/themes/prism.css"
      rel="stylesheet"
    />
    <link
      href="https://unpkg.com/prismjs@1.20.0/plugins/line-numbers/prism-line-numbers.css"
      rel="stylesheet"
    />
  </head>
  <body>
    <script
      type="text/javascript"
      src="https://unpkg.com/prismjs@1.20.0/prism.js"
    ></script>
    <script
      type="text/javascript"
      src="https://unpkg.com/prismjs@1.20.0/plugins/unescaped-markup/prism-unescaped-markup.js"
    ></script>
    <script
      type="text/javascript"
      src="https://unpkg.com/prismjs@1.20.0/plugins/line-numbers/prism-line-numbers.js"
    ></script>
    <!-- Keep Markup assumes markup is around the code text, so would need to wrap the code and add the icons afterwards -->
    <!-- <script>
      Prism.hooks.add('before-highlight', (env) => {
        const beforeText = new Text(env.code.slice(0, 229))
        console.log(beforeText.data.slice(-40))
        const afterText = new Text(env.code.slice(229))
        console.log(afterText.data.slice(0, 40))

        const link = document.createElement('a')
        link.href = '#'
        link.textContent = ''

        env.element.textContent = ''
        env.element.appendChild(beforeText)
        env.element.appendChild(link)
        env.element.appendChild(afterText)
      })
    </script>
    <script
      type="text/javascript"
      src="https://unpkg.com/prismjs@1.20.0/plugins/keep-markup/prism-keep-markup.js"
    ></script> -->

    <!-- 
      TODO:

      Consider manually walking the post highlighted DOM tree counting columns (characters in Text node)
      and lines ("\n" characters for Prism) and inserting markers for deopts

      Looking a theme.browser.js, consider putting markers at the end of the current token if inside of a token
     -->

    <script type="text/javascript">
      /**
       * @param {Node} element
       * @param {Node} root
       */
      function nextElement(element, root) {
        if (element == root) {
          return null
        } else if (element.firstChild) {
          return element.firstChild
        } else if (element.nextSibling) {
          return element.nextSibling
        } else {
          do {
            element = element.parentNode
          } while (element && element != root && !element.nextSibling)

          return element ? element.nextSibling : null
        }
      }

      Prism.hooks.add('after-highlight', (env) => {
        const locations = [
          { type: 'code', line: 9, column: 27 },
          { type: 'deopt', line: 109, column: 17 },
          { type: 'ics', line: 109, column: 17 },
        ]

        let code = ''

        /** @type {Node} */
        const root = env.element
        /** @type {Node} */
        let element = root.firstChild
        let line = 1,
          column = 1
        while (element) {
          if (element.nodeType == 3 /* TEXT_NODE */) {
            const text = element.data
            code += text

            const lines = text.split('\n')
            if (lines.length > 1) {
              line += lines.length - 1
              column = lines[lines.length - 1].length
            } else {
              column += element.data.length
            }
          }

          element = nextElement(element, root)
        }

        console.log(line, column, line == 158 && column == 7)
        console.log(code == env.code)
      })
    </script>

    <pre
      class="language-markup line-numbers"
    ><code id="code"><!--<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Adders (inline)</title>
  </head>
  <body>
    <script type="module">
      class Object1 {
        constructor(x, y) {
          this.x = x
          this.y = y
        }
      }

      class Object2 {
        constructor(x, y) {
          this.y = y
          this.x = x
        }
      }

      class Object3 {
        constructor(x, y) {
          this.hello = 'world'
          this.x = x
          this.y = y
        }
      }

      class Object4 {
        constructor(x, y) {
          this.x = x
          this.hello = 'world'
          this.y = y
        }
      }

      class Object5 {
        constructor(x, y) {
          this.x = x
          this.y = y
          this.hello = 'world'
        }
      }

      class Object6 {
        constructor(x, y) {
          this.hola = 'mundo'
          this.x = x
          this.y = y
          this.hello = 'world'
        }
      }

      class Object7 {
        constructor(x, y) {
          this.x = x
          this.hola = 'mundo'
          this.y = y
          this.hello = 'world'
        }
      }

      class Object8 {
        constructor(x, y) {
          this.x = x
          this.y = y
          this.hola = 'mundo'
          this.hello = 'world'
        }
      }
      // We access this object in all the functions as otherwise
      // v8 will just inline them since they are so short
      const preventInlining = {
        flag: false,
      }

      function addSmis(a, b) {
        if (preventInlining.flag) return a - b
        return a + b
      }

      function addNumbers(a, b) {
        if (preventInlining.flag) return a - b
        return a + b
      }

      function addStrings(a, b) {
        if (preventInlining.flag) return a - b
        return a + b
      }

      function addAny(a, b) {
        if (preventInlining.flag) return a - b
        // passed one object?
        if (b == null) return a.x + a.y
        return a + b
      }

      const ITER = 1e3

      var results = []

      function processResult(r) {
        // will never happen
        if (r === -1) preventInlining.flag = true
        results.push(r)
        // prevent exhausting memory
        if (results.length > 1e5) results = []
      }

      for (let i = 0; i < ITER; i++) {
        for (let j = ITER; j > 0; j--) {
          processResult(addSmis(i, j))
          processResult(addNumbers(i, j))
          processResult(addNumbers(i * 0.2, j * 0.2))
          processResult(addStrings(`${i}`, `${j}`))
          // Just passing Smis for now
          processResult(addAny(i, j))
        }
      }

      for (let i = 0; i < ITER; i++) {
        for (let j = ITER; j > 0; j--) {
          // Adding Doubles
          processResult(addAny(i * 0.2, j * 0.2))
        }
      }

      for (let i = 0; i < ITER; i++) {
        for (let j = ITER; j > 0; j--) {
          // Adding Strings
          processResult(addAny(`${i}`, `${j}`))
        }
      }

      function addObjects(SomeObject) {
        for (let i = 0; i < ITER; i++) {
          for (let j = ITER; j > 0; j--) {
            processResult(addAny(new SomeObject(i, j)))
          }
        }
      }
      addObjects(Object1)
      addObjects(Object2)
      addObjects(Object3)
      addObjects(Object4)
      addObjects(Object5)
      addObjects(Object6)
      addObjects(Object7)
      addObjects(Object8)

      console.log(results.length)
    </script>
  </body>
</html>--></code></pre>
  </body>
</html>
